<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++指针小结</title>
    <url>/2022/06/01/C++%E6%8C%87%E9%92%88%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p><strong>1.占用内存：</strong>在32为操作系统下（即x86）指针占4个字节空间；在64位操作系统下指针占8个字节空间，不管是什么数据类型。</p>
<p><strong>2.空指针：</strong>指针变量指向内存中编号为0的空间；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>​	<strong>用途：</strong>初始化指针变量</p>
<p>​	<strong>注意：</strong>空指针的内存是不可以访问的；内存编号0~255为系统占用内存，不允许用户访问</p>
<p>**3.野指针:**指针变量指向非法内存空间</p>
<p>​	在程序中尽量避免出现野指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="number">0x1100</span>;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>空指针和野指针都不是我们申请的空间，因此不要访问</p>
<p><strong>4.<code>const</code>修饰指针</strong></p>
<ul>
<li><p><code>const</code>修饰指针    —<strong>常量指针：指针的指向可以修改，但是指针指向的值不可以改</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;a; <span class="comment">//常量指针</span></span><br><span class="line">*p = <span class="number">20</span>;           <span class="comment">//错误：指针指向的值不可以改</span></span><br><span class="line">p = &amp;b;            <span class="comment">//正确：指针指向可以改</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>const</code>修饰常量    —<strong>指针常量：指针的指向不可以改，指针指向的值可以改</strong></p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;a; <span class="comment">//指针常量</span></span><br><span class="line">*p = <span class="number">20</span>;           <span class="comment">//正确：指向的值可以改</span></span><br><span class="line">p = &amp;b;            <span class="comment">//错误：指针指向不可以改</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>const</code>既修饰指针又修饰常量    —<strong>特点：指针的指向和指针指向的值都不可以改</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p = &amp;a; <span class="comment">//既修饰指针又修饰常量</span></span><br><span class="line">*p = <span class="number">20</span>;                 <span class="comment">//错误：指向的值不可以改</span></span><br><span class="line">p = &amp;b;                  <span class="comment">//错误：指针指向不可以改</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>5.指针和数组</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//访问数组中的第一个元素</span></span><br><span class="line">p++;               <span class="comment">//或者*p++</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//访问数组中的第二个元素</span></span><br></pre></td></tr></table></figure>

<p><strong>6.指针和函数</strong></p>
<p>​	<strong>注意：</strong>普通函数使用时利用形参来进行函数运算，即只是将实参中的值赋予形参，即<strong>值传递</strong>；如果想改变实参中的值，则需要将实参的地址赋予函数，即进行<strong>地址传递</strong>，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap2</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如果是<strong>地址传递</strong>，可以修饰实参。</p>
<p><strong>7.将指针综合在数组和函数中</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序法函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">BubbleSort</span>(arr, <span class="number">10</span>);                 <span class="comment">//数组名就是数组的首地址！！！</span></span><br><span class="line">	<span class="type">int</span>* p = arr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：数组名就是数组的首地址</strong></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程——1 内存分区模型</title>
    <url>/2022/06/06/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%941-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li><p><strong>代码区：</strong>存放函数体的二进制代码，由操作系统进行管理</p>
</li>
<li><p><strong>全局区：</strong>存放全局变量和静态变量以及常量</p>
</li>
<li><p><strong>栈区：</strong>由编译器自动分配释放，存放函数的参数值，局部变量等</p>
</li>
<li><p><strong>堆区：</strong>由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</p>
<p>  <strong>内存四区存在的意义：</strong></p>
<pre><code>  不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程
</code></pre>
</li>
</ul>
<span id="more"></span>

<h5 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h5><pre><code>在程序编译后生成了`exe`可执行程序，**未执行该程序前**分为两个区域：

**代码区：**

    存放CPU执行的机器指令

    代码区是**共享的**，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

    代码区是**只读的**，使其只读的原因是防止程序异外修改了它的指令

**全局区：**

    全局变量和静态变量存放在此

    全局区还包含了常量区，字符串常量和其他常量也存放在此

    **该区域的数据在程序结束后由操作系统释放**
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p_a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> p_b = <span class="number">200</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_p_a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_a = <span class="number">1000</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_b = <span class="number">2000</span>;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_a = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量a的地址：&quot;</span> &lt;&lt; (<span class="type">int</span>) &amp; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量b的地址：&quot;</span> &lt;&lt; (<span class="type">int</span>) &amp; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量p_a的地址：&quot;</span> &lt;&lt; (<span class="type">int</span>) &amp; p_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量p_b的地址：&quot;</span> &lt;&lt; (<span class="type">int</span>) &amp; p_b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_a的地址：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_b的地址：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量‘helloworld’的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;helloworld&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;const修饰的全局变量(全局常量)c_p_a的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_p_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;const修饰的局部变量(局部常量)c_a的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>总结：
</code></pre>
<ul>
<li>C++中在程序运行期前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放<code>const</code>修饰的全局变量和字符串常量</li>
</ul>
<h5 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h5><pre><code>**栈区：**

    由编译器自动分配释放，存放函数的参数值，局部变量等

    **注意事项：**不要返回局部变量的地址，栈区开辟的数据由编译器自动释放
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//局部变量 存放在栈区，栈区的数据在函数执行完后自动释放</span></span><br><span class="line">	<span class="keyword">return</span> &amp;a;<span class="comment">//返回局部变量的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="built_in">func</span>();</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//第一次可以打印正确的数字，是因为编译器做了保留</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//第二次这个数据就不再保留</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：一般项目运行在x86上，注意此时的x86和x64区别</span></span><br></pre></td></tr></table></figure>

<pre><code>**堆区：**

    由程序员分配释放，若程序员不释放，程序结束时由操作系统回收

    在C++中主要利用`new`在堆区中开辟内存
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//利用new关键字，可以将数据开辟至堆区</span></span><br><span class="line">	<span class="comment">//指针本质也是局部变量，放在栈上，指针保存的数据放在堆中</span></span><br><span class="line">	<span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="built_in">func</span>();</span><br><span class="line">	cout &lt;&lt; * a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; * a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h5><pre><code>C++中利用`new`操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符`delete`

语法：`new 数据类型`

利用`new`创建的数据，会返回该数据对应的类型的指针
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//在堆中创建整型数据</span></span><br><span class="line">	<span class="comment">//new返回的是该数据类型的指针</span></span><br><span class="line">	<span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用new在堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] arr;<span class="comment">//释放数组时，delete后应加[]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="built_in">func</span>();</span><br><span class="line">	cout &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//delete释放内存</span></span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; *a &lt;&lt; endl;//内存以释放，非法操作</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程——2 引用</title>
    <url>/2022/06/06/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%942-%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h4 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h4><h5 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h5><pre><code>**作用：**给变量起别名

**语法：**`数据类型 &amp;别名 = 原名`
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>&amp; b = a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	b = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-引用的注意事项"><a href="#2-2-引用的注意事项" class="headerlink" title="2.2 引用的注意事项"></a>2.2 引用的注意事项</h5><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//int&amp; b;//错误：引用必须初始化</span></span><br><span class="line">	<span class="type">int</span>&amp; b = a;<span class="comment">//正确</span></span><br><span class="line">	<span class="type">int</span> c = <span class="number">20</span>;</span><br><span class="line">	b = c;<span class="comment">//赋值操作，而不是更改引用</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h5><pre><code>**作用：**函数传参时，可以利用引用的技术让形参修饰实参

**优点：**可以简化指针修改实参
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap01</span>(a, b);<span class="comment">//值传递：形参不会修饰实参</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap02</span>(&amp;a, &amp;b);<span class="comment">//地址传递：形参会修饰实参</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap03</span>(a, b);<span class="comment">//引用传递：形参会修饰实参</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>通过引用参数产生的效果通地址传递是一样的。引用的语法更简单清楚。</p>
<h5 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h5><pre><code>作用：引用可以作为函数的返回值存在

**注意：不要返回局部变量引用**

用法：函数调用作为左值
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用做函数的返回值</span></span><br><span class="line"><span class="comment">//1.不要返回局部变量的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//局部变量存放在四区中的 栈区</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.函数的调用可以作为左值</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> b = <span class="number">20</span>;<span class="comment">//静态变量，存放在全局区</span></span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>&amp; ref1 = <span class="built_in">test01</span>();</span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; ref1 &lt;&lt; endl;<span class="comment">//第一次编译器做了保留</span></span><br><span class="line">	cout &lt;&lt; ref1 &lt;&lt; endl;<span class="comment">//第二次错误，a的内存已经释放</span></span><br><span class="line">	cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;<span class="comment">//如果函数的返回值是引用，那么函数的调用可以作为左值</span></span><br><span class="line">	cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h5><pre><code>本质：**引用的本质在C++内部实现是一个指针常量**
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现引用，转换为 int&amp; const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">//ref是引用，内部转换为 *ref = 100;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>&amp; ref = a;</span><br><span class="line">	<span class="comment">//自动转换为 int* const ref = &amp;a;指针常量是指针指向不可改，也说明引用为什么不可以更改</span></span><br><span class="line">	ref = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//内部发现 ref 是引用自动转换为 *ref = 20;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：C++推荐使用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h5 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h5><pre><code>作用：常量引用主要用来修饰形参，防止误操作

在函数形参列表中，可以加 `const`修饰形参，防止形参改变实参
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//val = 100;//防止修改实参</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;val = &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//常量引用</span></span><br><span class="line">	<span class="comment">//修饰形参，防止误操作</span></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;//错误：引用必须因一块合法的内存空间</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//加上const之后 编译器将代码修改为 int temp = 10；int* ref = temp；</span></span><br><span class="line">	<span class="comment">//ref = 20；//错误：加入const之后变为只读，不可修改</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">show</span>(a);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程——4 类和对象- 4.1 封装</title>
    <url>/2022/06/06/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%944-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-4-1-%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><pre><code>C++面向对象的三大特性为：**封装、继承、多态**

C++认为**万事万物皆为对象**，对象上有其属性和行为

**例如：**

    人可以作为对象，属性有姓名、年龄、身高...，行为有走、跑、跳...

    车可以作为对象，属性有轮胎、方向盘...,行为有载人、放音乐...

    具有相同性质的**对象**，我们可以抽象为**类**，人属于人类，车属于车类
</code></pre>
<h5 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h5><h6 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1 封装的意义"></a>4.1.1 封装的意义</h6><pre><code>封装是C++面对对象的三大特性之一

封装的意义：
</code></pre>
<ul>
<li><p>将属性和行为作为一个整体，表现生活中的事物</p>
</li>
<li><p>将属性和行为加以权限控制</p>
<p>  <strong>封装意义一：</strong></p>
<pre><code>  在设计类的时候，属性和行为写在一起，表现事物
</code></pre>
<p>  <strong>语法：</strong><code>class 类名&#123; 访问权限： 属性 / 行为 &#125;;</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="comment">//设计一个圆类，求圆的周长</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//访问权限</span></span><br><span class="line">	<span class="comment">//公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="type">double</span> r;</span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="comment">//返回圆的周长</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">primeter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * r * pi;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回圆的面积</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> r * r * pi;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过圆类创建具体的圆（对象）</span></span><br><span class="line">	<span class="comment">//实例化：通过一个类创建一个对象的过程</span></span><br><span class="line">	Circle c1;</span><br><span class="line">	c1.r = <span class="number">1</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;圆的周长为：&quot;</span> &lt;&lt; c1.<span class="built_in">primeter</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;圆的面积为：&quot;</span> &lt;&lt; c1.<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>**封装意义二：**

    类在设计时，可以把属性和行为放在不同权限下，加以控制

    访问权限有三种：

        1.`public`        **公共权限：**类内可以访问  类外可以访问

        2.`protected`  **保护权限：**类内可以访问  类外不可以访问  子类可以访问父类中的保护权限

        3.`private`      **私有权限：**类内可以访问  类外不可以访问  子类不可以访问父类中的保护权限
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string p_name;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string p_car;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> p_password;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(string name, string car, <span class="type">int</span> password)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		p_name = name;</span><br><span class="line">		p_car = car;</span><br><span class="line">		p_password = password;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p1;</span><br><span class="line">	p1.<span class="built_in">set</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;拖拉机&quot;</span>, <span class="number">123</span>);</span><br><span class="line">	cout &lt;&lt; p1.p_name &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; p1.p_car &lt;&lt; endl;//保护权限类外不可以访问</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; p1.p_password &lt;&lt; endl;//私有权限类外不可以访问</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h6><pre><code>在C++中`struct`和`class`唯一的**区别**就在于**默认的访问权限不同**

区别：
</code></pre>
<ul>
<li><code>struct</code>默认权限为<strong>公有</strong></li>
<li><code>class</code>  默认权限为<strong>私有</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;<span class="comment">//默认权限：私有</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> b;<span class="comment">//默认权限：公有</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	C1 c1;</span><br><span class="line">	C2 c2;</span><br><span class="line">	<span class="comment">//c1.a = 10;//不可访问</span></span><br><span class="line">	c2.b = <span class="number">30</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h6><pre><code>**优点1：**将所有成员属性设置为私有，可以自己控制读写权限

**优点2：**对于写权限，我们可以检测数据的有效性
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string p_name;<span class="comment">//设置为可读可写</span></span><br><span class="line">	<span class="type">int</span> p_age = <span class="number">18</span>;<span class="comment">//设置为只读不写</span></span><br><span class="line">	string p_lover;<span class="comment">//设置为只写不读</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//设置名字可写接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		p_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置名字可读接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p_name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置年龄只读接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;年龄为：&quot;</span> &lt;&lt; p_age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置爱人只写接口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		p_lover = lover;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p1;</span><br><span class="line">	p1.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	p1.<span class="built_in">setLover</span>(<span class="string">&quot;桃子女士&quot;</span>);</span><br><span class="line">	p1.<span class="built_in">showName</span>();</span><br><span class="line">	p1.<span class="built_in">showAge</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程——3 函数提高</title>
    <url>/2022/06/06/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%943-%E5%87%BD%E6%95%B0%E6%8F%90%E9%AB%98/</url>
    <content><![CDATA[<h5 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h5><pre><code>在C++中，函数的形参列表中的形参是可以有默认值的

语法：`返回值类型 函数名 （参数 = 默认值）&#123;&#125;`
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数默认参数</span></span><br><span class="line"><span class="comment">//如果我们传入数据，就用自己的数据，否则就用默认值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">20</span>, <span class="type">int</span> c = <span class="number">30</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意！：</span></span><br><span class="line"><span class="comment">//1、如果某个位置已经有了默认参数，那么从这个位置以后都要有默认参数</span></span><br><span class="line"><span class="comment">//int func1(int a = 10, int b, int c)//错误：a后面的b、c没有默认参数</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	return a + b = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、如果函数声明有默认参数，函数实现就不能有默认参数</span></span><br><span class="line"><span class="comment">// 声明和实现只能有一个默认参数</span></span><br><span class="line"><span class="comment">//int func2(int a = 10,int b =10)//函数声明有默认参数</span></span><br><span class="line"><span class="comment">//int func2(int a = 20,int b =20)//错误：函数实现也有了默认参数</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	return a + b;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func</span>(a,<span class="number">30</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h5 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h5><pre><code>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置

**语法：**`返回值类型 函数名 （数据类型）&#123;&#125;`
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数</span></span><br><span class="line"><span class="comment">//占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;This is a function!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h5><h6 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h6><pre><code>**作用：**函数名可以相同，提高复用性

**函数重载满足条件**
</code></pre>
<ul>
<li><p>同一个作用域下</p>
</li>
<li><p>函数名称相同</p>
</li>
<li><p>函数参数<strong>类型不同</strong> 或者<strong>个数不同</strong> 或<strong>顺序不同</strong></p>
<p>  <strong>注意：</strong>函数的返回值不可以作为函数重载的条件</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;函数func()的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;函数func(int a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;函数func(int a,double b)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;函数func(int a,double b)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数的返回值不能作为函数重载的条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;函数func(int a,double b)的调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>, <span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-3-2-函数重载的注意事项"><a href="#3-3-2-函数重载的注意事项" class="headerlink" title="3.3.2 函数重载的注意事项"></a>3.3.2 函数重载的注意事项</h6><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载的注意事项</span></span><br><span class="line"><span class="comment">//1.引用作为重载条件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; a)</span><span class="comment">//int&amp; a = 10 不合法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;这是func(int&amp; a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span><span class="comment">//const int&amp; a = 10 合法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;这是const func(int&amp; a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.函数重载碰到函数默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;这是func2(int a, int b = 10)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;这是func2(int a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//func2(a);//当函数重载碰到默认参数就会出现二义性，重载尽量不要写默认参数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程——4 类和对象- 4.2 对象的初始化和清理</title>
    <url>/2022/06/06/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%944-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-4-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<h5 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h5><ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用的时候也会删除一些自己信息数据保证安全</li>
<li>C++的面向对象中来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置</li>
</ul>
<h6 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h6><pre><code>对象的**初始化和清理**也是两个非常重要的安全问题

    一个对象或者变量没有初始状态，对其使用后果是未知

    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题



C++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象的初始化和清理。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数，但其是空实现。**
</code></pre>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数有编译器自动调用，无需手动调用</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作</li>
</ul>
<span id="more"></span>

<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写<code>void</code></li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时会自动调用构造，无需手动调用，而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong><code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写<code>void</code></li>
<li>函数名称与类名相同，在名称前加上符号<code>~</code></li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//1 创建创建构函数</span></span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是Person构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2 创建析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是Person析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;<span class="comment">//在栈上的数据，test01执行完毕后，会释放这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	Person p2;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);<span class="comment">////若不加pause，那么系统不会暂停，对象就会被释放</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h6><pre><code>两种分类方式：

    按参数分为：有参构造和无参构造

    按类型分为：普通构造和构造拷贝

三种调用方式：

    括号法

    显示法

    隐式转换法
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的无参调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的有参调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造参数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的拷贝构造参数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//将传入的人身上所有的属性，拷贝到我身上</span></span><br><span class="line">		age = p.age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.括号法</span></span><br><span class="line">	Person p1;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄：&quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄：&quot;</span> &lt;&lt; p3.age &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//注意事项</span></span><br><span class="line">	<span class="comment">//调用默认构造函数时，不要加()</span></span><br><span class="line">	<span class="comment">//因为下面这行代码，编译器会认为是一个函数的声明,不会认为在创建对象</span></span><br><span class="line">	<span class="comment">//Person p1();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.显示法</span></span><br><span class="line">	Person p4;<span class="comment">//无参构造</span></span><br><span class="line">	Person p5 = <span class="built_in">Person</span>(<span class="number">10</span>);<span class="comment">//有参构造</span></span><br><span class="line">	Person p6 = <span class="built_in">Person</span>(p5);<span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="number">10</span>);<span class="comment">//匿名对象 特点：当前行执行结束后，系统会立即回收掉匿名对象</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;$$$&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意事项2</span></span><br><span class="line">	<span class="comment">//不要利用拷贝构造函数初始化匿名对象,编译器会认为 Person(p3) === Person p3</span></span><br><span class="line">	<span class="comment">//Person(p3);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.隐式转换法</span></span><br><span class="line">	Person p7 = <span class="number">10</span>;<span class="comment">//相当于 Person p7 = Person(10)</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h6><pre><code>C++中拷贝构造函数调用时机通常由三种情况
</code></pre>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> p_age;</span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		p_age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		p_age = p.p_age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数调用时机</span></span><br><span class="line"><span class="comment">//1.使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄：&quot;</span> &lt;&lt; p2.p_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.值传递的方式给函数参数传值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;***********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;***********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h6><pre><code>默认情况下，C++编译器至少给一个类添加3个函数
</code></pre>
<ol>
<li><p>默认构造函数（无参，函数体为空）</p>
</li>
<li><p>默认析构函数（无参，函数体为空）</p>
</li>
<li><p>默认拷贝构造参数，对属性进行值拷贝</p>
<p> 构造函数调用规则如下：</p>
</li>
</ol>
<ul>
<li>如果用户定义有参构造函数，C++不会提供默认无参构造，但是会提供默认拷贝构造</li>
<li>如果用户定义拷贝构造参数，C++不会再提供其他构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/构造函数的调用规则</span><br><span class="line"><span class="comment">//1、创建一个类，C++编译器会给每个类都添加至少三个函数</span></span><br><span class="line"><span class="comment">// 默认构造 （空实现）</span></span><br><span class="line"><span class="comment">// 析构函数 （空实现）</span></span><br><span class="line"><span class="comment">// 拷贝构造 （值拷贝）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、如果我们写了有参构造函数，编译器就不再提供默认构造，依然提供拷贝构造</span></span><br><span class="line"><span class="comment">//3、如果我们写了拷贝构造函数，编译器就不再提供其他构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> p_age;</span><br><span class="line">	<span class="comment">/*Person()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;Person默认构造函数调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="comment">/*Person(int age)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		p_age = age;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		p_age = p.p_age;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void test01()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	Person p;</span></span><br><span class="line"><span class="comment">//	p.p_age = 18;</span></span><br><span class="line"><span class="comment">//	Person p2(p);</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;p2的年龄：&quot; &lt;&lt; p2.p_age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//void test02()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	Person p(28);</span></span><br><span class="line"><span class="comment">//	Person p2(p);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Person p;//只提供拷贝构造函时，编译器不会提供其他构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h6><pre><code>深拷贝时面试经典问题，也是常见的一个坑
</code></pre>
<ul>
<li>浅拷贝：简单的复制拷贝操作</li>
<li>深拷贝：在堆区重新申请空间，进行拷贝操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深拷贝与浅拷贝</span></span><br><span class="line"><span class="comment">//浅拷贝带来的问题就是堆区的内存重复释放</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> p_age;</span><br><span class="line">	<span class="type">int</span>* p_height;</span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age,<span class="type">int</span> height)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		p_age = age;</span><br><span class="line">		p_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//自己实现拷贝构造函数 解决浅拷贝带来的问题</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person拷贝构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		p_age = p.p_age;</span><br><span class="line">		<span class="comment">//p_height = p.p_height;//编译器默认实现就是这行代码</span></span><br><span class="line">		<span class="comment">//深拷贝操作</span></span><br><span class="line">		p_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.p_height);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//析构代码，将堆区开辟数据做释放操作</span></span><br><span class="line">		<span class="keyword">if</span> (p_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> p_height;</span><br><span class="line">			p_height = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>,<span class="number">160</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄：&quot;</span> &lt;&lt; p1.p_age &lt;&lt; <span class="string">&quot; p1的身高：&quot;</span> &lt;&lt; *p1.p_height &lt;&lt; endl;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄：&quot;</span> &lt;&lt; p2.p_age &lt;&lt; <span class="string">&quot; p2的身高：&quot;</span> &lt;&lt; *p2.p_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h6><pre><code>**作用：**

    C++提供了初始化列表语法，用来初始化操作
</code></pre>
<p>​	</p>
<pre><code>**语法：**`构造函数():属性1(值1),属性2(值2)...&#123;&#125;`
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> p_a;</span><br><span class="line">	<span class="type">int</span> p_b;</span><br><span class="line">	<span class="type">int</span> p_c;</span><br><span class="line">	<span class="comment">//传统初始化操作</span></span><br><span class="line">	<span class="comment">/*Person(int a, int b, int c)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		p_a = a;</span></span><br><span class="line"><span class="comment">		p_b = b;</span></span><br><span class="line"><span class="comment">		p_c = c;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化列表初始化属性</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c) :<span class="built_in">p_a</span>(a), <span class="built_in">p_b</span>(b), <span class="built_in">p_c</span>(c)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p_a = &quot;</span> &lt;&lt; p.p_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p_b = &quot;</span> &lt;&lt; p.p_b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p_c = &quot;</span> &lt;&lt; p.p_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h6><pre><code>C++类中的成员可以是另一个类的对象，我们称该成员为 **对象成员**
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序时谁先谁后？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		p_PName = pName;</span><br><span class="line">	&#125;</span><br><span class="line">	string p_PName;</span><br><span class="line">	~<span class="built_in">Phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string p_Name;</span><br><span class="line">	Phone p_Phone;</span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName) :<span class="built_in">p_Name</span>(name), <span class="built_in">p_Phone</span>(pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;苹果MAX&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p.p_Name &lt;&lt; <span class="string">&quot;拿着&quot;</span> &lt;&lt; p.p_Phone.p_PName &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当其他类对象作为本类成员，构造是先构造对象，再构造自身；析构的顺序相反</span></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h6><pre><code>静态成员就是在成员变量和成员函数前加上关键字`static`，称为静态成员

静态成员分类：
</code></pre>
<ul>
<li>静态成员变量<ul>
<li>所有对象共享一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li>所有对象共享一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1：</strong>静态成员变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//1、所有对象都共享同一份数据</span></span><br><span class="line">	<span class="comment">//2、编译阶段就分配内存</span></span><br><span class="line">	<span class="comment">//3、类内声明，类外初始化操作</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> p_A;</span><br><span class="line">	<span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> p_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::p_A = <span class="number">100</span>;<span class="comment">//类外初始化</span></span><br><span class="line"><span class="type">int</span> Person::p_B = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; p.p_A &lt;&lt; endl;</span><br><span class="line">	Person p2;</span><br><span class="line">	p2.p_A = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; p.p_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量 不属于某个对象，所有对象都共享同一份数据</span></span><br><span class="line">	<span class="comment">//因此静态成员有两种访问方式</span></span><br><span class="line">	<span class="comment">//1、通过对象进行访问</span></span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; p.p_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//2、通过类名进行访问</span></span><br><span class="line">	cout &lt;&lt; Person::p_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; Person::p_B &lt;&lt; endl;//类外访问不到私有静态成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong>静态成员函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态成员函数</span></span><br><span class="line"><span class="comment">//所有对象共享一个函数</span></span><br><span class="line"><span class="comment">//静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//静态成员函数</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//p_B = 100;//报错：静态成员函数不可以访问非静态成员变量，无法区分到底是那个对象的p_B</span></span><br><span class="line">		p_A = <span class="number">100</span>;<span class="comment">//静态成员变量可以访问静态成员变量</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;static void func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> p_A;<span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="type">int</span> p_B;</span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;static void func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::p_A;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、通过对象访问</span></span><br><span class="line">	Person p;</span><br><span class="line">	p.<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//2、通过类名访问</span></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//Person::func2();//类外访问不到私有的静态成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程——4 类和对象- 4.3 C++对象模型和this指针</title>
    <url>/2022/06/06/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%944-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-4-3-C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h5 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h5><h6 id="4-3-1-成员变量和成员函数分开储存"><a href="#4-3-1-成员变量和成员函数分开储存" class="headerlink" title="4.3.1 成员变量和成员函数分开储存"></a>4.3.1 成员变量和成员函数分开储存</h6><pre><code>在C++中，类内的成员变量和成员函数分开储存

只有非静态成员变量才属于类的对象上
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员变量和成员函数分开储存</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person01</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person02</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> p_A;<span class="comment">//非静态成员变量 属于类的对象</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> p_B;<span class="comment">//静态成员变量 不属于类的对象上</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//非静态成员函数 不属于类的对象上</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//静态成员函数 不属于类的对象上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person02::p_B;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person01 p1;</span><br><span class="line">	<span class="comment">//空对象占用内存空间为：1</span></span><br><span class="line">	<span class="comment">//C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置</span></span><br><span class="line">	<span class="comment">//每个空对象也应该有一个独一无二的内存地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of p1 = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person02 p2;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of p2 = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h6 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h6><pre><code>通过4.3.1我们知道在C++中成员变量和成员函数是分开储存的

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分那个对象调用自己的呢？



C++通过提供特殊对象指针，`this`指针，解决上述问题。

**`this`指针指向被调用的成员函数所属的对象**



`this`指针是隐含每一个非静态成员函数内的一种指针

`this`指针不需要定义，直接使用即可



`this`指针的用途：
</code></pre>
<ul>
<li>当形参和成员变量同名是，可用<code>this</code>指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用<code>return *this</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//this指针指向的是 被调用的而成员函数所属的对象</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Person&amp; <span class="title">PeronAddAge</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//this指向p2的指针，而*this指向的就是p2这个对象本体</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1、解决名称冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p的年龄为：&quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、返回对象本身用*this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="comment">//链式编程思想</span></span><br><span class="line">	p2.<span class="built_in">PeronAddAge</span>(p1).<span class="built_in">PeronAddAge</span>(p1).<span class="built_in">PeronAddAge</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h6><pre><code>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到`this`指针
</code></pre>
<p>​	</p>
<pre><code>如果用到`this`指针，需要加以判断保证代码的健壮性
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针调用成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> p_age;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;this is Person class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//报错原因是因为传入的指针是为NULL</span></span><br><span class="line">		<span class="comment">//添加判定条件，增加代码健壮性</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; p_age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person* p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">showClassName</span>();</span><br><span class="line">	p-&gt;<span class="built_in">showPersonAge</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h6><pre><code>**常函数：**
</code></pre>
<ul>
<li><p>成员函数后加const后我们称这个函数为<strong>常函数</strong></p>
</li>
<li><p>常函数内不可以修改成员属性</p>
</li>
<li><p>成员属性声明时加关键字<code>mutable</code>后，在常函数中依然可以改</p>
<p>  <strong>常对象：</strong></p>
</li>
<li><p>声明对象前加<code>const</code>称该对象为常对象</p>
</li>
<li><p>常对象只能调用常函数</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> p_A;</span><br><span class="line">	<span class="comment">//特殊变量，即使在常函数中，也可以修改这个值，加关键字mutable</span></span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> p_B;</span><br><span class="line">	<span class="comment">//this指针的本质 是指针常量 指针的指向是不可以修改的</span></span><br><span class="line">	<span class="comment">//const Person* const this</span></span><br><span class="line">	<span class="comment">//在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//this-&gt;p_A = 100;</span></span><br><span class="line">		<span class="comment">//this = NULL;//this指针不可以修改指针的指向</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;p_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> Person p;<span class="comment">//在对象前加const，变为常对象</span></span><br><span class="line">	<span class="comment">//p.p_A = 100;//报错</span></span><br><span class="line">	p.p_B = <span class="number">100</span>;<span class="comment">//特殊值，在常对象下也可以修改</span></span><br><span class="line">	<span class="comment">//常对象只能调用常函数</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	<span class="comment">//常对象不可以调用普通成员函数，因为普通成员函数可以修改属性</span></span><br><span class="line">	<span class="comment">//p.func();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程——4 类和对象- 4.4 友元</title>
    <url>/2022/06/06/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%944-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-4-4-%E5%8F%8B%E5%85%83/</url>
    <content><![CDATA[<h5 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h5><pre><code>在程序里，有些私有属性 也想让类外一些函数或者类进行访问，就需要用到友元的技术



友元的目的就是让一个函数或者类 访问另一个类中私有成员

友元的关键字为 `friend`

友元的三种实现 
</code></pre>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<span id="more"></span>

<h6 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局函数做友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//goodGuy全局函数是Building的好朋友，可以访问其中的私有成员</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGuy</span><span class="params">(Building* building)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_LivingRoom;</span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_LivingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGuy</span><span class="params">(Building* building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好朋友全局函数 正在访问：&quot;</span> &lt;&lt; building-&gt;m_LivingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好朋友全局函数 正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Building building;</span><br><span class="line">	<span class="built_in">goodGuy</span>(&amp;building);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类做友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">GoodGuy</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_LivingRoom;</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGuy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Building* building;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//参观函数 访问Building中的属性</span></span><br><span class="line">	<span class="built_in">GoodGuy</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外写成员函数</span></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	m_LivingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">GoodGuy::<span class="built_in">GoodGuy</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//创建建筑物对象</span></span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGuy::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好朋友类正在访问：&quot;</span> &lt;&lt; building-&gt;m_LivingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好朋友类正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GoodGuy gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员函数做友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGuy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">GoodGuy</span>();</span><br><span class="line">	<span class="comment">//让visit函数可以访问Building中私有成员</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//让visit2函数不可以访问Building中的私有成员</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;</span><br><span class="line">	Building* building;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GoodGuy::visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_LivingRoom;</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外实现成员函数</span></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	m_LivingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">GoodGuy::<span class="built_in">GoodGuy</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGuy::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;visit函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_LivingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;visit函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGuy::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;visit函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_LivingRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GoodGuy gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line">	gg.<span class="built_in">visit2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程——4 类和对象- 4.5 运算符重载</title>
    <url>/2022/06/06/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%944-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-4-5-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h5 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h5><pre><code>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型
</code></pre>
<h6 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h6><pre><code>作用：实现两个自定义数据类型相加的运算
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加号运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="comment">//1、成员函数重载+号运算符</span></span><br><span class="line">	<span class="comment">/*Person operator+(Person&amp; p)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		Person temp;</span></span><br><span class="line"><span class="comment">		temp.m_A = this-&gt;m_A + p.m_A;</span></span><br><span class="line"><span class="comment">		temp.m_B = this-&gt;m_B + p.m_B;</span></span><br><span class="line"><span class="comment">		return temp;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2、全局函数重载+号</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p1, Person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">	temp.m_B = p1.m_B + p2.m_B;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p1, <span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p1.m_A + num;</span><br><span class="line">	temp.m_B = p1.m_B + num;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	p1.m_A = <span class="number">10</span>;</span><br><span class="line">	p1.m_B = <span class="number">10</span>;</span><br><span class="line">	Person p2;</span><br><span class="line">	p2.m_A = <span class="number">10</span>;</span><br><span class="line">	p2.m_B = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//Person p3 = p1.operator+(p2);//成员函数重载本质调用</span></span><br><span class="line">	<span class="comment">//Person p3 = operatoe+(p1,p2);//全局函数重载本质调用</span></span><br><span class="line">	Person p3 = p1 + p2;</span><br><span class="line">	<span class="comment">//运算符重载也可以发生函数重载</span></span><br><span class="line">	Person p4 = p1 + <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3.m_A = &quot;</span> &lt;&lt; p3.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3.m_B = &quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p4.m_A = &quot;</span> &lt;&lt; p4.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p4.m_B = &quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<blockquote>
<p>总结1：对于内置的数据类型的表达式的运算符是不可能改变的</p>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h6 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h6><pre><code>作用：可以输出自定义数据类型
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左移运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="comment">//利用成员函数重载 左移运算符 p.operator&lt;&lt;(cout) 简化版本 p &lt;&lt; cout</span></span><br><span class="line">	<span class="comment">//不会利用成员函数重载&lt;&lt;运算符，因为无法实现cout在左侧</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能利用全局函数重载左移运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; m_B = &quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	p.m_A = <span class="number">10</span>;</span><br><span class="line">	p.m_B = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h6 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h6><pre><code>作用：通过重载递增运算符，实现自己的整型数据
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重载递增运算符</span></span><br><span class="line"><span class="comment">//自定义整型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载前置++运算符  返回引用为了一直对一个数据进行操作</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载后置++运算符</span></span><br><span class="line">	<span class="comment">//int代表占位参数，可以用于区分前置和后置递增</span></span><br><span class="line"> 	MyInteger&amp; <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//先 记录当时结果</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="comment">//后 递增</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="comment">//最后将记录结果做返回</span></span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重载&lt;&lt;运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; p.m_Num;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyInteger myint;</span><br><span class="line">	cout &lt;&lt; ++myint &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myint++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：前置递增返回引用，后置递增返回值</p>
</blockquote>
<h6 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h6><pre><code>C++编译器至少给一个类添加4个函数
</code></pre>
<ol>
<li><p>默认构造函数（无参，函数体为空）</p>
</li>
<li><p>默认析构函数（无参，函数体为空）</p>
</li>
<li><p>默认拷贝构造函数，对属性进行拷贝</p>
</li>
<li><p>赋值运算符<code>operator=</code>，对属性进行值拷贝</p>
<p> 如果类中有属性指向堆区，做赋值操作也会出现深浅拷贝问题</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span>* m_Age;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载赋值运算符</span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//编译器是提供浅拷贝</span></span><br><span class="line">		<span class="comment">//m_Age = p.m_Age</span></span><br><span class="line">		<span class="comment">//应该先判断是否有属性在堆区 如果有，先释放干净 然后再深拷贝</span></span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//深拷贝</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line">		<span class="comment">//返回对象本身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">	p3 = p2 = p1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h6><pre><code>**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关系运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载==号</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Name == p.m_Name &amp;&amp; m_Age == p.m_Age)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (p1 == p2)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1和p2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1和p2不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-5-6-函数调用运算符重"><a href="#4-5-6-函数调用运算符重" class="headerlink" title="4.5.6 函数调用运算符重"></a>4.5.6 函数调用运算符重</h6><ul>
<li>函数调用运算符<code>()</code>也可以重载</li>
<li>由于重载后使用的方式非常想&#x3D;像函数的的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数调用运算符重载</span></span><br><span class="line"><span class="comment">//打印输出类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//重载函数调用运算符</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint02</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//由于使用起来非常类似于函数 因此称为仿函数</span></span><br><span class="line">	<span class="built_in">MyPrint02</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//仿函数非常灵活，没有固定的写法</span></span><br><span class="line"><span class="comment">//加法类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 + num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd myadd;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myadd</span>(<span class="number">100</span>, <span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//匿名函数对象</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">300</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程——4 类和对象- 4.6 继承</title>
    <url>/2022/06/06/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%944-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-4-6-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h5 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6 继承"></a>4.6 继承</h5><pre><code>**继承是面向对象三大特性之一**

有些类与类之间存在特殊关系，定义某些类时，下级别的成员除了拥有上一级的共性，还有自己的特性

这个时候我们就可以考虑利用继承的技术，减少重复代码
</code></pre>
<h6 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h6><pre><code>**语法：**`class 子类 : 继承方式 父类`
</code></pre>
<ul>
<li><p>子类 也称为 派生类</p>
</li>
<li><p>父类 也称为 基类</p>
<p>  例如我们看到很多网站中，都有公共的头部，公共的的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>  接下来我们分别利用普通写法和继承写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
</li>
</ul>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承实现</span></span><br><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册。。。（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、合作交流、站内地图。。。（公共底部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java、Python、C++。。。（公共分类列表）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//继承公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span>:<span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//继承的好处：减少重复代码</span></span><br><span class="line"><span class="comment">//语法：class 子类 ： 继承方式 父类</span></span><br><span class="line"><span class="comment">//子类 也称为 派生类</span></span><br><span class="line"><span class="comment">//父类 也称为 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> :<span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java页面&quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python页面&quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>**派生类中的成员包含两大部分：**

    一类是从基类继承过来的，一类是自己增加的成员

从基类继承过来的表现其共性，而新增的成员体现了其个性
</code></pre>
<h6 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h6><pre><code>**继承的语法：**`class 子类 : 继承方式 父类`

**继承方式一共有三种：**
</code></pre>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A = <span class="number">10</span>;<span class="comment">//父类中的公共权限 到子类依然是公共权限</span></span><br><span class="line">		m_B = <span class="number">10</span>;<span class="comment">//父类中的保护权限 到子类依然是保护权限</span></span><br><span class="line">		<span class="comment">//m_C = 10;////父类中的私有权限 子类依然访问不到</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;<span class="comment">//父类中公共成员 到子类中变为保护权限</span></span><br><span class="line">		m_B = <span class="number">100</span>;<span class="comment">//父类中保护成员 到子类中变为保护权限</span></span><br><span class="line">		<span class="comment">//m_C = 100;//父类中私有成员 子类访问不到</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span> :<span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;<span class="comment">//父类中私有成员 到子类中变为私有权限</span></span><br><span class="line">		m_B = <span class="number">100</span>;<span class="comment">//父类中保护成员 到子类中变为私有权限</span></span><br><span class="line">		<span class="comment">//m_C = 100;//父类中私有成员 子类访问不到</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A = <span class="number">1000</span>;<span class="comment">//到了Son3中m_A变为私有，即使是儿子，也访问不到</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_A = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">//s1.m_B = 100;//到Son1中 m_B 是保护权限 类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s2;</span><br><span class="line">	<span class="comment">//s2.m_A = 1000;//在Son2中m_A变为保护权限，因此类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son3 s3;</span><br><span class="line">	<span class="comment">//s3.m_A = 1000;//到Son3中 变为 私有成员 类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h6><pre><code>**问题：**从父类继承过来的成员，哪些属于子类对象中？
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承中的对象模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用开发人员命令提示工具查看对象模型</span></span><br><span class="line"><span class="comment">//跳转盘符</span></span><br><span class="line"><span class="comment">//跳转文件路径 cd 具体路劲下</span></span><br><span class="line"><span class="comment">//查看命名</span></span><br><span class="line"><span class="comment">// cl /dl reportSingleClassLayout类名 文件名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//16</span></span><br><span class="line">	<span class="comment">//父类中所有非静态成员属性都会被子类继承下去</span></span><br><span class="line">	<span class="comment">//父类中私有成员属性 是被编译器给隐藏了 因此访问不到 但确实被继承下去了</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用开发人员命令提示工具查看对象模型：</p>
<ol>
<li>跳转盘符</li>
<li>跳转文件路径 <code>cd</code> 具体路径下</li>
<li>查看命名</li>
<li><code>cl /dl reportSingleClassLayout类名 文件名</code></li>
</ol>
</blockquote>
<blockquote>
<p>结论：父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h6 id="4-6-4-继承中的构造和析构顺序"><a href="#4-6-4-继承中的构造和析构顺序" class="headerlink" title="4.6.4 继承中的构造和析构顺序"></a>4.6.4 继承中的构造和析构顺序</h6><pre><code>子类继承父类后，当创建子类对象，也会调用父类的构造函数



**问题：**父类和子类的构造和析构顺序是谁先谁后？
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承中构造和析构顺序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Base b;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//继承中的构造和析构顺序如下：</span></span><br><span class="line">	<span class="comment">//先构造父类 再构造子类 析构的顺序与构造相反</span></span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>继承中的构造和析构顺序如下：<br>先构造父类 再构造子类 析构的顺序与构造相反</p>
</blockquote>
<h6 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h6><pre><code>**问题：**当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？
</code></pre>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承中同名成员处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base func() 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base func(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son func() 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承同名成员处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//如果通过子类对象 访问到父类中同名成员 需要加作用域</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承同名函数处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();<span class="comment">//直接调用 调用的是子类中的同名成员</span></span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//如果子类中出现和父类同名的成员函数 子类的同名成员会隐藏掉父类中所有同名成员函数（重载）</span></span><br><span class="line">	<span class="comment">//若要访问 需要加作用域</span></span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：</p>
<ul>
<li>子类对象可以直接访问到子类中同名函数</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ul>
</blockquote>
<h6 id="4-6-6-同名静态成员处理方式"><a href="#4-6-6-同名静态成员处理方式" class="headerlink" title="4.6.6 同名静态成员处理方式"></a>4.6.6 同名静态成员处理方式</h6><pre><code>问题：继承中同名的静态成成员在子类对象上如何进行访问？



静态成员与非静态成员出现同名，处理方式一致
</code></pre>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承中的同名静态成员处理方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base static void func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base static void func(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son static void func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"><span class="comment">//同名静态成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、通过对象访问</span></span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//2、通过类名访问数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第一个::代表通过类名的方式访问 第二个::代表访问父类作用域下</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同名静态成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、通过对象访问</span></span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//2、通过类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//子类出现和父类同名静态成员函数，也会隐藏父类中所有同名成员函数</span></span><br><span class="line">	<span class="comment">//如果想访问父类中被隐藏的同名成员，需要加作用域</span></span><br><span class="line">	Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h6><pre><code>C++允许**一个类继承多个类**
</code></pre>
<p>​	</p>
<pre><code>**语法：**`class 子类 : 继承方式 父类1 , 继承方式 父类2...`



多继承可能会引发父类中由同名成员出现，需要加作用域区分



**C++实际开发中不建议用多继承**
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多继承语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//子类 需要继承Base1和Base2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_C = <span class="number">300</span>;</span><br><span class="line">		m_D = <span class="number">400</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//当父类中出现同名成员，需要加作用域区分</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base1 m_A = &quot;</span> &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base2 m_A = &quot;</span> &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h6><pre><code>**菱形继承概念：**

    两个派生类继承同一个基类

    又有某个类同时继承这两个派生类

    这种继承被称为菱形继承，或者钻石继承



**菱形继承问题：**
</code></pre>
<ol>
<li>羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性</li>
<li>羊驼继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用虚继承 解决菱形继承的问题</span></span><br><span class="line"><span class="comment">//在继承之前 加上关键字 virtual 变为虚继承</span></span><br><span class="line"><span class="comment">// Animal类称之为 虚基类</span></span><br><span class="line"><span class="comment">//羊类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//驼类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//羊驼类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> :<span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">18</span>;</span><br><span class="line">	st.Tuo::m_Age = <span class="number">28</span>;</span><br><span class="line">	<span class="comment">//当菱形继承，两个父类拥有相同数据，需要加以作用域区分</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//这份数据我们知道 只有一份就可以 菱形继承导致数据有两份 资源浪费</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<blockquote>
<p>虚继承简述：</p>
<ol>
<li>两个类在继承同一个基类时，在继承方法前加上<code>virtual</code>关键字</li>
<li>这时第三级类继承的就是两个第二级类的<code>vbptr</code>，即<code>virtual base pointer</code>，虚基类指针</li>
<li>虚基类指针指向第二级的两个类，两个类具有不同的偏移量，相同的数据将会合并</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程——4 类和对象- 4.7 多态</title>
    <url>/2022/06/06/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%944-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-4-7-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h5 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7 多态"></a>4.7 多态</h5><h6 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h6><pre><code>**多态是C++面向对象三大特性之一**
</code></pre>
<p>​	</p>
<pre><code>多态分为两类：
</code></pre>
<ul>
<li><p>静态多态：函数重载 和 运算符重载属于静态多态，复用函数名</p>
</li>
<li><p>动态多态：派生类和虚函数实现运行时多态</p>
<p>  静态多态和动态多态的区别：</p>
</li>
<li><p>静态多态的函数地址早绑定 - 编译阶段确定函数地址</p>
</li>
<li><p>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</p>
</li>
</ul>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多态</span></span><br><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//猫类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//狗类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行说话的函数</span></span><br><span class="line"><span class="comment">//地址早绑定 在编译阶段确定函数地址</span></span><br><span class="line"><span class="comment">//如果想执行让猫说话 那么这个函数地址就不能提前绑定 需要在运行阶段进行绑定 地址晚绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态多态满足条件</span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类的虚函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态多态的使用</span></span><br><span class="line"><span class="comment">//父类的指针或者引用 指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSpeak</span><span class="params">(Animal&amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">doSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">doSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p><strong>多态满足条件：</strong></p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p><strong>多态使用条件：</strong></p>
<ul>
<li>父类指针或者引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p>
<h6 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h6><pre><code>案例描述：

    分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算机类



多态的优点：
</code></pre>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分别利用普通写法和多态技术实现计算器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果想扩展新的功能 需要修改源码</span></span><br><span class="line">		<span class="comment">//在真实开发中 提倡 开闭原则</span></span><br><span class="line">		<span class="comment">//开闭原则：对扩展进行开放，对修改进行关闭</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">	c.m_Num2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用多态实现计算器</span></span><br><span class="line"><span class="comment">//多态好处：</span></span><br><span class="line"><span class="comment">// 1、组织结构清晰</span></span><br><span class="line"><span class="comment">// 2、可读性强</span></span><br><span class="line"><span class="comment">// 3、对于前期和后期扩展以及维护性高</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现计算器抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//加法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//减法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//乘法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//多态使用条件</span></span><br><span class="line">	<span class="comment">//父类指针或者引用指向子类对象</span></span><br><span class="line">	<span class="comment">//利用指针</span></span><br><span class="line">	<span class="comment">//加法运算</span></span><br><span class="line">	AbstractCalculator* abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//用完后记得销毁</span></span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">	<span class="comment">//减法运算</span></span><br><span class="line">	<span class="comment">//堆区内存释放了 但是父类指针类型没有变</span></span><br><span class="line">	abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">	<span class="comment">//乘法运算</span></span><br><span class="line">	abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">doCal</span><span class="params">(AbstractCalculator&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.<span class="built_in">getResult</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AddCalculator a;</span><br><span class="line">	a.m_Num1 = <span class="number">20</span>;</span><br><span class="line">	a.m_Num2 = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">doCal</span>(a) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h6><pre><code>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容



因此可以将虚函数改为**纯虚函数**



纯虚函数语法：`virtual 返回值类型 函数名 (参数列表) = 0;`



当类中有了纯虚函数，这个类也称为**抽象类**



**抽象类特点：**
</code></pre>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//纯虚函数和抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="comment">//只要有一个纯虚函数 这个类称为抽象类</span></span><br><span class="line">	<span class="comment">//抽象类特点：</span></span><br><span class="line">	<span class="comment">//1、无法实例化对象</span></span><br><span class="line">	<span class="comment">//2、抽象类的子类 必须要重写父类中的纯虚函数 否则也属于抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Base b;  //抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//new Base;//抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//Son s;//子类必须要重写父类中的纯虚函数，否则无法实例化对象</span></span><br><span class="line">	Base* base = <span class="keyword">new</span> Son;</span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h6><pre><code>**案例描述：**

    制作饮品大大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料



利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多态案例 制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrink</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//煮水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomeThing</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//制作饮品</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">makeDrink</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomeThing</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> :<span class="keyword">public</span> AbstractDrink</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//煮水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮矿泉水&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;倒入杯中&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomeThing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶和糖&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//制作茶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> :<span class="keyword">public</span> AbstractDrink</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//煮水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮山泉水&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡茶叶&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;倒入盏中&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomeThing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入枸杞&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//制作饮品</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(AbstractDrink* drink)</span><span class="comment">//AbstractDrink* drink = new Coffee</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	drink-&gt;<span class="built_in">makeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">doWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">doWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h6><pre><code>多态使用时，如果子类中由属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码



解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**



虚析构和纯虚析构共性：
</code></pre>
<ul>
<li><p>可以解决父类指针释放子类对象</p>
</li>
<li><p>都需要具体的函数实现</p>
<p>  虚析构和纯虚析构区别：</p>
</li>
<li><p>如果是纯虚析构，该类属于抽象类，无法实例化对象</p>
<p>  虚析构语法：</p>
<p>  <code>virtual ~类名()&#123;&#125;</code></p>
<p>  纯虚析构语法：</p>
<p>  <code>virtual ~类名() = 0;</code></p>
<p>  <code>类名::类名()&#123;&#125;</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//虚析构和纯虚析构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//利用虚析构可以解决 父类指针释放子类对象时不干净的问题</span></span><br><span class="line">	<span class="comment">/*virtual ~Animal()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;Animal析构函数调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//纯虚析构 需要声明也需要实现</span></span><br><span class="line">	<span class="comment">//有了纯虚析构 之后 这个类也属于抽象类 无法实例化对象</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal纯析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string* m_Name;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Cat</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Name != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Cat析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">delete</span> m_Name;</span><br><span class="line">			m_Name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal* animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line">	<span class="comment">//父类指针在析构函数时候 不会调用子类中析构函数，导致子类如果有堆区属性，出现内存泄漏</span></span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</li>
<li>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</li>
<li>拥有纯虚析构函数的类也属于抽象类</li>
</ol>
<h6 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h6><pre><code>案例描述：

    电脑主要组成部件为CPU（用于计算），显卡（用于显示），内存条（用于存储）

    将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo

    创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口

    测试时组装三台不同的电脑进行工作
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多态案例三 电脑组装</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象的CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象的显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象的内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RAM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数中传入三个零件指针</span></span><br><span class="line">	<span class="built_in">Computer</span>(CPU* cpu,GPU* gpu,RAM* ram)</span><br><span class="line">	&#123;</span><br><span class="line">		m_CPU = cpu;</span><br><span class="line">		m_GPU = gpu;</span><br><span class="line">		m_RAM = ram;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//工作函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_CPU-&gt;<span class="built_in">calculate</span>();</span><br><span class="line">		m_GPU-&gt;<span class="built_in">show</span>();</span><br><span class="line">		m_RAM-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;computer析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_CPU != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_CPU;</span><br><span class="line">			m_CPU = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (m_GPU != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_GPU;</span><br><span class="line">			m_GPU = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (m_RAM != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_RAM;</span><br><span class="line">			m_RAM = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	CPU* m_CPU;</span><br><span class="line">	GPU* m_GPU;</span><br><span class="line">	RAM* m_RAM;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体零件厂商</span></span><br><span class="line"><span class="comment">//Lenovo</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoGPU</span> :<span class="keyword">public</span> GPU</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的GPU开始显示&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoRAM</span> :<span class="keyword">public</span> RAM</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的RAM开始存储&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Intel</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelGPU</span> :<span class="keyword">public</span> GPU</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的GPU开始显示&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelRAM</span> :<span class="keyword">public</span> RAM</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的RAM开始存储&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试案例01</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPU* cpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	GPU* gpu = <span class="keyword">new</span> IntelGPU;</span><br><span class="line">	RAM* ram = <span class="keyword">new</span> IntelRAM;</span><br><span class="line">	Computer* com = <span class="keyword">new</span> <span class="built_in">Computer</span>(cpu, gpu, ram);</span><br><span class="line">	com-&gt;<span class="built_in">doWork</span>();</span><br><span class="line">	<span class="keyword">delete</span> com;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试案例02</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPU* cpu = <span class="keyword">new</span> LenovoCPU;</span><br><span class="line">	GPU* gpu = <span class="keyword">new</span> LenovoGPU;</span><br><span class="line">	RAM* ram = <span class="keyword">new</span> LenovoRAM;</span><br><span class="line">	Computer* com = <span class="keyword">new</span> <span class="built_in">Computer</span>(cpu, gpu, ram);</span><br><span class="line">	com-&gt;<span class="built_in">doWork</span>();</span><br><span class="line">	<span class="keyword">delete</span> com;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试案例03</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPU* cpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	GPU* gpu = <span class="keyword">new</span> IntelGPU;</span><br><span class="line">	RAM* ram = <span class="keyword">new</span> LenovoRAM;</span><br><span class="line">	Computer* com = <span class="keyword">new</span> <span class="built_in">Computer</span>(cpu, gpu, ram);</span><br><span class="line">	com-&gt;<span class="built_in">doWork</span>();</span><br><span class="line">	<span class="keyword">delete</span> com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程——5 文件操作</title>
    <url>/2022/06/06/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%945-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h4><p>​	程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>​	通过<strong>文件可以将数据持久化</strong></p>
<p>​	C++中对文件操作需要包含头文件<code>&lt; fstream &gt;</code></p>
<p>​	文件类型分为两种：</p>
<ul>
<li>文本文件：文件以文本的<strong>ASCII码</strong>形式储存在计算机中</li>
<li>二进制文件：文件以文本的<strong>二进制形式</strong>存储在计算机就中，用户一般不能直接读懂他们</li>
</ul>
<p>​	</p>
<p>​	操作文件的三大类：</p>
<ul>
<li><code>ofstream</code>：写操作</li>
<li><code>ifstream</code>：读操作</li>
<li><code>fstream </code>  ：读写操作</li>
</ul>
<span id="more"></span>

<h5 id="5-1-文本文件"><a href="#5-1-文本文件" class="headerlink" title="5.1 文本文件"></a>5.1 文本文件</h5><h6 id="5-1-1-写文件"><a href="#5-1-1-写文件" class="headerlink" title="5.1.1 写文件"></a>5.1.1 写文件</h6><p>​	写文件步骤如下：<br>​	1、包含头文件</p>
<p>​		<code>#include &lt;fstream&gt;</code></p>
<p>​	2、创建流对象</p>
<p>​		<code>ofstream ofs;</code></p>
<p>​	3、打开文件</p>
<p>​		<code>ofs.open(&quot;文件路径&quot;,打开方式);</code></p>
<p>​	4、写数据</p>
<p>​		<code>ofs &lt;&lt; &quot;写入的数据&quot;;</code></p>
<p>​	5、关闭文件</p>
<p>​		<code>ofs.close();</code></p>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th align="left"><strong>打开方式</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ios::in</code></td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td align="left"><code>ios::out</code></td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td align="left"><code>ios::ate</code></td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td align="left"><code>ios::app</code></td>
<td>追加方式写文件</td>
</tr>
<tr>
<td align="left"><code>ios::trunc</code></td>
<td>如果文件存在，先删除，再创建</td>
</tr>
<tr>
<td align="left"><code>ios::binary</code></td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>文件打开方式可以配合使用，利用<code>|</code>操作符</p>
<p><strong>例如：</strong>用二进制方式写文件<code>ios::binary | ios::out</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文本文件 写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、包含头文件 fstream</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、创建流对象</span></span><br><span class="line">	ofstream ofs;</span><br><span class="line">	<span class="comment">//3、指定打开方式</span></span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line">	<span class="comment">//4、写内容</span></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//5、关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件操作必须包含头文件<code>fstream</code></li>
<li>读文件可以利用<code>ofstream</code>或者<code>fstream</code></li>
<li>打开文件时需要指定操作文件的路径，以及打开方式</li>
<li>利用<code>&lt;&lt;</code>可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h6 id="5-1-2-读文件"><a href="#5-1-2-读文件" class="headerlink" title="5.1.2 读文件"></a>5.1.2 读文件</h6><p>​	读文件与写文件步骤相似，但是读取方式比较多</p>
<p>​	读文件步骤如下：</p>
<p>​		1、包含头文件</p>
<p>​			<code>#include &lt;fstream&gt;</code></p>
<p>​		2、创建流对象</p>
<p>​			<code>ifstream ifs;</code></p>
<p>​		3、打开文件并判断文件是否成功打开</p>
<p>​			<code>ifs.open(&quot;文件路径&quot;,打开方式);</code></p>
<p>​		4、读数据</p>
<p>​			四种方式读取</p>
<p>​		5、关闭文件</p>
<p>​			<code>ifs.close();</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文本文件 读文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4、读数据</span></span><br><span class="line">	<span class="comment">//第一种</span></span><br><span class="line">	<span class="type">char</span> buf1[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; buf1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; buf1 &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line">	<span class="type">char</span> buf2[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (ifs.<span class="built_in">getline</span>(buf2, <span class="built_in">sizeof</span>(buf2)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line">	string buf3;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(ifs, buf3))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; buf3 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="comment">//第四种</span></span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)<span class="comment">//EOF: end of file</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h5><p>​	以二进制的方式对文件进行读写操作</p>
<p>​	打开方式为<code>ios::binary</code></p>
<h6 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h6><p>​	二进制方式写文件主要利用流对象调用成员函数<code>write</code></p>
<p>​	函数原型：<code>ostream&amp; write(const char* buffer,int len);</code></p>
<p>​	参数解释：字符指针<code>buffer</code>指向内存中一段存储空间。<code>len</code>是读写的字节数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件 写文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>, ios::binary | ios::out);</span><br><span class="line">	Person p = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span> &#125;;</span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h6><p>​	二进制方式读文件主要利用流对象调用成员函数<code>read</code></p>
<p>​	函数原型：<code>istream&amp; read(char* buffer,int len);</code></p>
<p>​	参数解释：字符指针<code>buffer</code>指向内存中一段存储空间。<code>len</code>是读写的字节数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件 读文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>, ios::binary | ios::in);</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++结构体小结</title>
    <url>/2022/06/01/C++%E7%BB%93%E6%9E%84%E4%BD%93%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<ul>
<li>​	结构体属于用户<strong>自定义的数据类型</strong>，允许用户存储不同的数据类型</li>
</ul>
<p><strong>1.结构体的定义和使用</strong></p>
<p>​	<strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;;</code></p>
<p>​	通过结构体创建变量的方式有三种：</p>
<ul>
<li><p>​	struct 结构体名 变量名</p>
</li>
<li><p>​	struct 结构体名 变量名 &#x3D; { 成员1值 , 成员2值…}</p>
</li>
<li><p>​	定义结构体时顺便创建变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个学生结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">&#125;s3;<span class="comment">//方式3：定义结构体时顺便创建变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Student</span> s1;<span class="comment">//方式1</span></span><br><span class="line">	s1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	s1.age = <span class="number">18</span>;</span><br><span class="line">	s1.score = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Student</span> s2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">99.5</span> &#125;;<span class="comment">//方式2</span></span><br><span class="line">	s3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">	s3.age = <span class="number">17</span>;</span><br><span class="line">	s3.score = <span class="number">59.4</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; s1姓名：&quot;</span> &lt;&lt; s1.name &lt;&lt; <span class="string">&quot; s1年龄：&quot;</span> &lt;&lt; s1.age &lt;&lt; <span class="string">&quot; s1成绩：&quot;</span> &lt;&lt; s1.score &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; s2姓名：&quot;</span> &lt;&lt; s2.name &lt;&lt; <span class="string">&quot; s2年龄：&quot;</span> &lt;&lt; s2.age &lt;&lt; <span class="string">&quot; s2成绩：&quot;</span> &lt;&lt; s2.score &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; s3姓名：&quot;</span> &lt;&lt; s3.name &lt;&lt; <span class="string">&quot; s3年龄：&quot;</span> &lt;&lt; s3.age &lt;&lt; <span class="string">&quot; s3成绩：&quot;</span> &lt;&lt; s3.score &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：输出String类型时，必须在程序头加上`#include &lt;string&gt;`</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	<strong>注意：</strong><code>struct</code>关键字在初始化时也可省略</p>
<span id="more"></span>

<p><strong>2.结构体数组</strong></p>
<ul>
<li><p><strong>作用：</strong>将自定义的结构体放入数组中方便维护</p>
</li>
<li><p><strong>语法：</strong><code>struct 结构体名 数组名[元素个数] = &#123; &#123;&#125;,&#123;&#125;,...,&#123;&#125;&#125;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Student arr[<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">18</span>,<span class="number">99.5</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">17</span>,<span class="number">59.4</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	arr[<span class="number">0</span>].name = <span class="string">&quot;赵六&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot; 成绩：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3.结构体指针</strong></p>
<p>​	<strong>作用：</strong>通过指针访问结构体中的成员</p>
<ul>
<li><p>利用操作符<code>-&gt;</code>可以通过结构体指针访问结构体属性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Student s1 = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">20</span>,<span class="number">100</span> &#125;;</span><br><span class="line">	Student* p = &amp;s1;<span class="comment">//定义指针时也要用结构体定义!!!</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 成绩：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4.结构体嵌套结构体</strong></p>
<p>​	<strong>作用：</strong>结构体中的成员可以是另一个结构体</p>
<p>​	<strong>例如：</strong>每个老师教1个学生，一个老师的结构体中，记录一个学生的结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个老师结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	string name;</span><br><span class="line">	Student stu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Student s1 = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">20</span>,<span class="number">100</span> &#125;;</span><br><span class="line">	Teacher t1 = &#123; <span class="number">123456</span>,<span class="string">&quot;李老师&quot;</span>,s1 &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; 教职工编号：&quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; t1.name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; 所带学生姓名为：&quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">&quot; 年龄为：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">&quot; 成绩为：&quot;</span> &lt;&lt; t1.stu.score &lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.结构体做函数参数</strong></p>
<p>​	<strong>作用：</strong>将结构体作为参数向函数中传递</p>
<p>​	传递方式有两种：</p>
<ul>
<li><p>值传递</p>
</li>
<li><p>地址传递</p>
<p><strong>注意：</strong>地址传递与值传递对实参本身的影响</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStu1</span><span class="params">(<span class="keyword">struct</span> Student s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s.name = <span class="string">&quot;李四&quot;</span>;<span class="comment">//修改值后注意控制台变化</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; s.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; s.age &lt;&lt; <span class="string">&quot; s成绩：&quot;</span> &lt;&lt; s.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStu2</span><span class="params">(<span class="keyword">struct</span> Student* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p-&gt;name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; s成绩：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Student s1 = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">20</span>,<span class="number">100</span> &#125;;</span><br><span class="line">	<span class="built_in">PrintStu1</span>(s1);</span><br><span class="line">	<span class="built_in">PrintStu2</span>(&amp;s1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; s1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; s1.age &lt;&lt; <span class="string">&quot; s成绩：&quot;</span> &lt;&lt; s1.score &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.结构体中<code>const</code>的使用场景</strong></p>
<p>​	<strong>作用：</strong>用<code>const</code>防止误操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将函数中的形参改为指针，可以减少内存使用，且不会复制新的副本出来</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStu</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> Student* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//p-&gt;name = &quot;王五&quot;;//操作失败，因为加入const</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; s成绩：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Student s1 = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">20</span>,<span class="number">100</span> &#125;;</span><br><span class="line">	<span class="built_in">PrintStu</span>(&amp;s1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基础操作</title>
    <url>/2022/05/29/Git%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h1><p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>官网地址为：<a href="https://git-scm.com/">https://git-scm.com/</a></p>
<p><strong>优点：</strong></p>
<p>适合分布式开发，强调个体；</p>
<p>公共服务器压力和数据量都不会太大；</p>
<p>速度快、灵活；</p>
<p>任意两个开发者之间可以很容易的解决冲突；</p>
<p>离线工作。</p>
<p><strong>缺点：</strong></p>
<p>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息；</p>
<p>权限控制不友好；如果需要对开发者限制各种权限的建议使用SVN。</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/flowchart.png" alt="Git分布式控制总流程图"></p>
<h1 id="Git基础操作"><a href="#Git基础操作" class="headerlink" title="Git基础操作"></a>Git基础操作</h1><h3 id="克隆远程仓库内容"><a href="#克隆远程仓库内容" class="headerlink" title="克隆远程仓库内容"></a>克隆远程仓库内容</h3><p>​	使用<code>git clone  </code>命令可以远程克隆代码托管平台，以GitHub平台为例，打开一个项目，在绿色的<code>code</code>处点击复制项目链接</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/gitcode.png"></p>
<p>在需要克隆的仓库点击鼠标右键打开<code>git bash</code>，在git bash中输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/crisp077/Git-test.git</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>克隆成功后出现如下字样</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/gitclone.png"></p>
<p>打开克隆好的项目</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/happen1.png"></p>
<p>我们可以发现一个GitHub项目就被克隆到了我们本地</p>
<h3 id="拉取远程仓库内容"><a href="#拉取远程仓库内容" class="headerlink" title="拉取远程仓库内容"></a>拉取远程仓库内容</h3><p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/change1.png"></p>
<p>​	在将项目克隆到本地文件后，如果项目更新，我们就可以利用<code>git pull </code>命令来同步远程仓库做出的改动</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>

<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/gitpull1.png"></p>
<p>就可以在仓库中看到更新的内容</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/happen2.png"></p>
<p>​	<strong>注意：</strong>看现在仓库的主分支是<code>master</code>还是<code>main</code>，如果为master，则为<code>git pull origin master</code></p>
<h3 id="更新远程仓库内容"><a href="#更新远程仓库内容" class="headerlink" title="更新远程仓库内容"></a>更新远程仓库内容</h3><p>​	如果我们在本地项目上进行更新，那么就需要利用<code>git push</code>命令将本地项目的更新同步到远程仓库，在执行<code>git push</code>完整命令之前，我们可以利用<code>git status</code>命令来查看更新了哪些内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>



<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/gitstatus.png"></p>
<p>由于我们之前在本地更新的内容属于工作区（会在status中显示为红色），在<code>git push</code>到远程仓库之前需要利用<code>git add</code>命令将其移动至暂存区（在status中显示为绿色），如果添加单个命令入缓存区可以输入<code>git add 文件名</code>，为了便利可以直接输入<code>git add .</code>，即添加所有文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>



<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/gitadd.png"></p>
<p>再次键入<code>git status</code>我们可以看到，本地新增的文件，其文件名由绿色变为红色，即从工作区成功移动到暂存区</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/gitstatus2.png"></p>
<p>在更新的文件存入暂存区后，还需要将其存入相对应的分支中，这是需要用的<code>git commit</code>命令，可以在commit后面键入对应的分支名，在分支名后可以添加本次更新内容的信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;hellogit文件添加&quot;</span></span><br></pre></td></tr></table></figure>

<p>再次用<code>git status</code>查看状态，可以看到状态栏里面为空，说明上传成功</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/gitcommit.png"></p>
<p>​	<strong>注意：</strong>第一次安装Git后，commit可能会出现下面提示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br></pre></td></tr></table></figure>

<p>这时按照提示重新输入这两行命令，将自己邮箱和昵称输入即可</p>
<p>接下来就可以使用<code>git push</code>命令将更新内容上传至远程仓库</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure>

<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/gitpush.png"></p>
<p>我们打开GitHub可以看到更新的内容，以及后面的更新说明</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/hellogitshow.png"></p>
<p>​	<strong>注意：</strong>在<code>git push</code>的过程中为了确保是本人对远程仓库的命令进行操作，一般会弹出弹窗让你输入远程仓库的密码，输入正确后就可以成功push；每次push都需要输入密码，显然很麻烦，我们可以通过<code>ssh-keygen -t rsa</code>来生成公钥，对远程仓库进行公钥配置，就可以实现免密推送。详情见<a href="https://blog.csdn.net/redrose2100/article/details/121668161">Github配置公钥</a>。</p>
<h3 id="版本追溯"><a href="#版本追溯" class="headerlink" title="版本追溯"></a>版本追溯</h3><p>​	在项目开发中经常会遇到各种问题，例如最新版本出现BUG，需要将版本回溯到以前的版本进行重新开发，这时候我们可以使用<code>git reset --hard 版本号</code> 命令来进行版本追溯，我们首先查看版本</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/reset1.png"></p>
<p>然后进入</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/reset2.png"></p>
<p>复制想要追溯的版本号，然后在本地项目中输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git reset --hard <span class="number">2</span>a871662d42a220a26f555a24cd0864a30352270</span><br></pre></td></tr></table></figure>

<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/reset3.png"></p>
<p>就可以切换至要追溯的版本，想要切换至最新版本则可以键入<code>git reset --hard 最新版本号</code>。</p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>​	在一个项目开发中，通常会有正式发布版和开发版，正式发布版一般存放在<code>main/master</code>主分支而开发版本则存放在其他分支。对于一个<code>git clone</code>后的项目，我们可以通过<code>git branch</code>来查看该项目下有几个分支</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/gitbranch.png"></p>
<p>可以看到，这个项目中只有一个分支，<code>main</code>即主分支。我们可以利用<code>git branch 分支名</code>来创建一个其他的分支例如创建一个<code>develop</code>分支</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git branch develop</span><br></pre></td></tr></table></figure>

<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/gitbranch2.png"></p>
<p>但是现在仍处于<code>main</code>分支，我们可以用<code>git checkout 分支名</code>切换到其他的分支</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git checkout develop</span><br></pre></td></tr></table></figure>

<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/gitbranch3.png"></p>
<p>可以看出已经切换至<code>develop</code>分支，然后在<code>develop</code>分支下新建一个文件<code>develop.txt</code></p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/gitbranch4.png"></p>
<p>然后用<code>git add</code>和<code>git commit</code>的一系列操作，将文件放入暂存区，准备更新远程仓库</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;develop提交&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后用<code>git checkout main</code>切换至主分支（也可以直接在<code>develop</code>分支直接输入，为了避免文件存放错误，一般在其他分支更新完成文件后建议切换至主分支进行操作），利用<code>git push</code>更新远程仓库（注意书写变化）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git push origin develop:develop</span><br></pre></td></tr></table></figure>

<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/develop.png"></p>
<p>点击<code>main</code>下面出现其他分支选项，点击切换至<code>develop</code>分支</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/develop2.png"></p>
<p>可以看到<code>develop</code> 分支下存在<code>develop.txt</code>文件</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/develop3.png"></p>
<p>当在<code>develop</code>或者其他分支的文件完全编写成功可以正式发布以后，我们就需要将<code>develop</code>或其他分支下的所做的更改应用到<code>main</code>分支上，这时候就需要用的<code>git merge</code>将<code>main</code>和<code>develop</code>进行合并，在<code>main</code>主分支中键入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git merge develop</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure>

<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/develop4.png"></p>
<p>进入主分支<code>main</code>，看可以看到有<code>develop.txt</code>文件的存在</p>
<p><img src="http://rco7kpoyg.hn-bkt.clouddn.com/develop5.png"></p>
<p>以上就是Git的基础的操作。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/05/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Markdown书写指南</title>
    <url>/2022/05/27/Markdown%E4%B9%A6%E5%86%99%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="Markdown基础语法"><a href="#Markdown基础语法" class="headerlink" title="Markdown基础语法"></a>Markdown基础语法</h1><h2 id="Markdown标题"><a href="#Markdown标题" class="headerlink" title="Markdown标题"></a>Markdown标题</h2><ul>
<li>一级标题对应一个<code>#</code>号；</li>
<li>二级标题对应两个<code>#</code>号；</li>
<li>以此类推，一共六级标题.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<h2 id="Markdown文本"><a href="#Markdown文本" class="headerlink" title="Markdown文本"></a>Markdown文本</h2><ul>
<li><p>斜体文本：可以在需要标注为斜体文本前及斜体文本结尾，输入一个星号 <code>*</code> 或者一个下划线 <code>_</code>；</p>
</li>
<li><p>粗体文本：可以在需要标注为粗体文本前及粗体文本结尾，输入两个星号 <code>**</code> 或者两个下划线 <code>_</code>；</p>
</li>
<li><p>粗斜体文本：可以在需要标注为粗斜体文本前及粗斜体文本结尾，输入三个星号 <code>***</code> 或者三个下划线 <code>_</code>；</p>
<span id="more"></span></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">    </span><br><span class="line">_斜体文本_</span><br><span class="line"></span><br><span class="line">**粗体文本**</span><br><span class="line"></span><br><span class="line">__粗体文本__</span><br><span class="line"></span><br><span class="line">***粗斜体文本***</span><br><span class="line"></span><br><span class="line">___粗斜体文本___</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="Markdown列表"><a href="#Markdown列表" class="headerlink" title="Markdown列表"></a>Markdown列表</h2><ul>
<li>无序列表，使用星号(<code>*</code>)、加号(<code>+</code>)或是减号(<code>-</code>)，再加一个空格作为列表标记；</li>
<li>有序列表，使用数字并加上 <code>.</code> 号，再加一个空格作为列表标记；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">* 无序列表 <span class="number">1</span></span><br><span class="line">+ 无序列表 <span class="number">2</span></span><br><span class="line">- 无序列表 <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 有序列表 <span class="number">1</span></span><br><span class="line"><span class="number">2.</span> 有序列表 <span class="number">2</span></span><br><span class="line"><span class="number">3.</span> 有序列表 <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="Markdown链接"><a href="#Markdown链接" class="headerlink" title="Markdown链接"></a>Markdown链接</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Markdown引用"><a href="#Markdown引用" class="headerlink" title="Markdown引用"></a>Markdown引用</h2><p>引用的格式是在符号 <code>&gt;</code> 后面书写文字，或者加一个空格再加文字，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; 这是一个引用：</span><br><span class="line">&gt; 欢迎关注三月江东个人博客</span><br><span class="line">&gt;&gt; 这是一个二级嵌套</span><br><span class="line">&gt;&gt;&gt; 这是一个三级嵌套</span><br></pre></td></tr></table></figure>

<h2 id="Markdown分割线"><a href="#Markdown分割线" class="headerlink" title="Markdown分割线"></a>Markdown分割线</h2><p>可以在一行中用三个 <code>-</code> 或者 <code>*</code> 来建立一个分隔线，同时需要在分隔线的上面空一行，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">欢迎关注博客</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">【三月江东】</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">* * *</span><br><span class="line">*****</span><br><span class="line">- - - </span><br></pre></td></tr></table></figure>

<h2 id="Markdown删除线"><a href="#Markdown删除线" class="headerlink" title="Markdown删除线"></a>Markdown删除线</h2><p>删除线的使用，在需要删除的文字前后各使用两个 <code>~</code>，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~~这是要被删除的内容。~~</span><br></pre></td></tr></table></figure>

<h2 id="Markdown下划线"><a href="#Markdown下划线" class="headerlink" title="Markdown下划线"></a>Markdown下划线</h2><p>下划线的使用，在需要添加下划线的文字首部和尾部加上 <code>&lt;u&gt;文本&lt;/u&gt;</code>，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;这行文字已被添加下划线&lt;/u&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Markdown表格"><a href="#Markdown表格" class="headerlink" title="Markdown表格"></a>Markdown表格</h2><p>表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行，如果想调整表格的左对齐、右对齐、居中对齐:</p>
<ul>
<li><code>:-</code>：将表头及单元格的内容左对齐；</li>
<li><code>-:</code>：将表头及单元格的内容左对齐；</li>
<li><code>:-:</code>：将表头及单元格的内容居中对齐。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">| 姓名   	| 年龄 |      工作	 |</span><br><span class="line">| :----- 	| :--: | -------:	 |</span><br><span class="line">| 小可爱 	|  <span class="number">18</span>  | 吃可爱多 	 |</span><br><span class="line">| 小小勇敢 	|  <span class="number">20</span>  | 爬棵勇敢树 	 |</span><br><span class="line">| 小小小机智 |  <span class="number">22</span>  | 看一本机智书 |</span><br></pre></td></tr></table></figure>

<h2 id="Markdown图片"><a href="#Markdown图片" class="headerlink" title="Markdown图片"></a>Markdown图片</h2><p>插入图片，如果是行内图片则无图例，否则有图例，格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">![图片描述](图片地址)</span><br></pre></td></tr></table></figure>

<p>支持 <code>jpg、png、gif、svg</code> 等图片格式，<strong>其中 svg 文件仅可在微信公众平台中使用</strong>。</p>
<p><strong>注</strong>：仅支持 https 的图片，图片粘贴到网页编辑器后，会自动上传到服务器；如果是本地编辑器，需要有一个相对路径用来存储保存的图片。</p>
<h2 id="Markdown注脚"><a href="#Markdown注脚" class="headerlink" title="Markdown注脚"></a>Markdown注脚</h2><p>脚注是对文本的备注说明，脚注与链接的区别，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">链接：[文字](链接)</span><br><span class="line">脚注：[文字](脚注解释 <span class="string">&quot;脚注名字&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Markdown代码"><a href="#Markdown代码" class="headerlink" title="Markdown代码"></a>Markdown代码</h2><p>如果在一个行内需要引用代码，只要用反引号引起来就好，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Use the `<span class="built_in">printf</span>()` function.</span><br></pre></td></tr></table></figure>

<p>如果是在一个块内需要引用代码，则在需要高亮的代码块的前一行及后一行使用三个反引号，同时 <strong>第一行反引号后面表示代码块所使用的语言</strong>，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FileName: HelloWorld.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支持以下语言种类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line">c，clojure，cpp，cs，css</span><br><span class="line">dart，dockerfile, diff</span><br><span class="line">erlang</span><br><span class="line">go，gradle，groovy</span><br><span class="line">haskell</span><br><span class="line">java，javascript，json，julia</span><br><span class="line">kotlin</span><br><span class="line">lisp，lua</span><br><span class="line">makefile，markdown，matlab</span><br><span class="line">objectivec</span><br><span class="line">perl，php，python</span><br><span class="line">r，ruby，rust</span><br><span class="line">scala，shell，sql，swift</span><br><span class="line">tex，typescript</span><br><span class="line">verilog，vhdl</span><br><span class="line">xml</span><br><span class="line">yaml</span><br></pre></td></tr></table></figure>

<p>本文转载自CSDN<br>博主: 我是管小亮<br>原文链接：<a href="https://blog.csdn.net/TeFuirnever/article/details/104255022">https://blog.csdn.net/TeFuirnever/article/details/104255022</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>书写语言</tag>
      </tags>
  </entry>
</search>
